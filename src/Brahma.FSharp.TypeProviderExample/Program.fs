// Copyright (c) 2017 Kirill Smirenko <k.smirenko@gmail.com>
// All rights reserved.
//
// The contents of this file are made available under the terms of the
// Eclipse Public License v1.0 (the "License") which accompanies this
// distribution, and is available at the following URL:
// http://www.opensource.org/licenses/eclipse-1.0.php
//
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
// the specific language governing rights and limitations under the License.
//
// By using this software in any fashion, you are agreeing to be bound by the
// terms of the License.

module Brahma.FSharp.TypeProviderExample

open System.IO
open OpenCL.Net
open Brahma.FSharp.OpenCL.Core
open Brahma.FSharp.OpenCL.Extensions
open Brahma.FSharp.OpenCL.TypeProvider.Provided
open Brahma.Helpers
open Brahma.OpenCL

// Path to included OpenCL C source
let [<Literal>] clSourcePath = "assignArr.cl"
// Type generated by TypeProvider, which contains OpenCL kernel headers from included source
type Provided = KernelProvider<clSourcePath, TreatPointersAsArrays=true>

type Runner() =
    let length = 8
    let gpuArr = Array.init length (fun _ -> 0)

    member this.Run platformName =
        let deviceType = DeviceType.Default
        // Number of work items that make up a work group
        // This value must be chosen carefully, taking your GPU specs into account
        // See OpenCL documentation for details:
        // https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clEnqueueNDRangeKernel.html
        let localWorkSize = 2

        // Load OpenCL C source as text, as it must be included when compiling kernels
        let additionalClSource = System.IO.File.ReadAllText(Path.Combine(__SOURCE_DIRECTORY__, clSourcePath))

        // Init compute resources
        let computeProvider =
            try ComputeProvider.Create(platformName, deviceType)
            with
            | ex -> failwith ex.Message
        let mutable commandQueue = new CommandQueue(computeProvider, computeProvider.Devices |> Seq.head)

        let workArray = gpuArr
        // Quotation to be compiled and run on GPU with Brahma.FSharp and OpenCL
        let command =
            <@
                fun (r:_1D) (a:array<_>) ->
                    Provided.assignArr(a)
            @>

        // Compile the kernel
        let kernel, kernelPrepare, kernelRun =
            computeProvider.Compile(command, _additionalSources = [additionalClSource])
        let dimensions =(new _1D(length, localWorkSize))
        // Load actual parameters to the kernel
        kernelPrepare dimensions workArray

        // Run the kernel on GPU
        let _ = commandQueue.Add(kernelRun()).Finish()
        // Retrieve output array (workArray) from GPU
        let _ = commandQueue.Add(workArray.ToHost computeProvider).Finish()

        // Do what you need with the output, e.g. validate output data
        let _, isSuccess = Array.fold (fun (index, flag) v -> index + 1, flag && v = index) (0, true) workArray

        commandQueue.Dispose()
        computeProvider.Dispose()
        computeProvider.CloseAllBuffers()

        isSuccess

[<EntryPoint>]
let main argv =
    let success = Runner().Run "NVIDIA*"
    if success
    then printfn "GPU run was successful."
    else printfn "GPU run was unsuccessful (unexpected output data)!"
    0
